{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DSA-Online LeetCode Solutions","text":"<p>Welcome to my collection of LeetCode problem solutions!</p> <p>This site contains detailed explanations and implementations of various LeetCode problems.</p>"},{"location":"#problem-categories","title":"Problem Categories","text":"<ul> <li>Array</li> <li>Hash Table</li> <li>Dynamic Programming</li> <li>Tree</li> <li>Graph</li> <li>and more...</li> </ul>"},{"location":"#latest-solutions","title":"Latest Solutions","text":"<ul> <li>1. Two Sum</li> <li>2. Add Two Number</li> <li>2226. Maximum Candies Allocated to K Children</li> </ul>"},{"location":"solutions/1/","title":"1. Two Sum","text":"","tags":["Array","Hash Table"]},{"location":"solutions/1/#1-two-sum","title":"1. Two Sum","text":"","tags":["Array","Hash Table"]},{"location":"solutions/1/#description","title":"Description","text":"<p>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</p> <p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p> <p>You can return the answer in any order.</p> <p>Example 1:</p> <pre><code>Input: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n</code></pre> <p>Example 2:</p> <pre><code>Input: nums = [3,2,4], target = 6\nOutput: [1,2]\n</code></pre> <p>Example 3:</p> <pre><code>Input: nums = [3,3], target = 6\nOutput: [0,1]\n</code></pre> <p>Constraints:</p> <ul> <li>2 &lt;= nums.length &lt;= 104</li> <li>-109 &lt;= nums[i] &lt;= 109</li> <li>-109 &lt;= target &lt;= 109</li> <li>Only one valid answer exists.</li> </ul> <p>Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?</p>","tags":["Array","Hash Table"]},{"location":"solutions/1/#solutions","title":"Solutions","text":"","tags":["Array","Hash Table"]},{"location":"solutions/1/#approach-1-hash-table","title":"Approach 1: Hash Table","text":"<p>\u2705 Time complexity: O(n)</p> <p>\u2705 Space complexity: O(n)</p> <p>Notes:</p> <p>We can use the hash table <code>seen</code> to store the array value and the corresponding index.</p> <p>Traverse the array <code>nums</code>, when you find <code>target - nums[i]</code> in the hash table, it means that the target value is found, and the index of <code>target - nums[i]</code> and <code>i</code> are returned.</p> <p>The time complexity is O(n) and the space complexity is O(n). Where n is the length of the array nums.</p> PythonJavaC++GoTypeScriptRustJavaScriptC#PHPScalaSwiftRubyKotlinNimCangjie <pre><code>class Solution:\n    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n        seen = {} #map elements with their indexs {ele:idx}\n        for idx,ele in enumerate(nums):\n            num = target - ele\n            if num in seen:\n                return [seen[num],idx]\n            seen[ele] = idx\n</code></pre> <pre><code>class Solution {\n    public int[] twoSum(int[] nums, int target) {\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n\n    }\n};\n</code></pre> <pre><code>func twoSum(nums []int, target int) []int {\n}\n</code></pre> <pre><code>function twoSum(nums: number[], target: number): number[] {}\n</code></pre> <pre><code>impl Solution {\n    pub fn two_sum(nums: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;i32&gt; {\n\n    }\n}\n</code></pre> <pre><code>/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number[]}\n*/\nvar twoSum = function (nums, target) {}\n</code></pre> <pre><code>public class Solution {\n    public int[] TwoSum(int[] nums, int target) {\n    }\n}\n</code></pre> <pre><code>class Solution {\n    /**\n    * @param Integer[] $nums\n    * @param Integer $target\n    * @return Integer[]\n    */\n    function twoSum($nums, $target) {\n    }\n}\n</code></pre> <pre><code>object Solution {\n    def twoSum(nums: Array[Int], target: Int): Array[Int] = {\n    }\n}\n</code></pre> <pre><code>class Solution {\n    func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] {\n\n    }\n}\n</code></pre> <pre><code># @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer[]}\ndef two_sum(nums, target)\n\nend\n</code></pre> <pre><code>class Solution {\n    fun twoSum(nums: IntArray, target: Int): IntArray {\n\n    }\n}\n</code></pre> <pre><code>proc twoSum(nums: seq[int], target: int): seq[int] =\n</code></pre> <pre><code>class Solution {\n    func twoSum(nums: Array&lt;Int64&gt;, target: Int64): Array&lt;Int64&gt; {\n\n    }\n}\n</code></pre>","tags":["Array","Hash Table"]},{"location":"solutions/2/","title":"2. Add Two Number","text":"","tags":["Linked List","Math","Recursion"]},{"location":"solutions/2/#2-add-two-numbers","title":"2. Add Two Numbers","text":"","tags":["Linked List","Math","Recursion"]},{"location":"solutions/2/#description","title":"Description","text":"<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p> <p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p> <p>Example 1:</p> <p></p> <pre><code>Input: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n</code></pre> <p>Example 2:</p> <pre><code>Input: l1 = [0], l2 = [0]\nOutput: [0]\n</code></pre> <p>Example 3:</p> <pre><code>Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n</code></pre> <p>Constraints:</p> <ul> <li><code>The number of nodes in each linked list is in the range [1, 100].</code></li> <li><code>0 &lt;= Node.val &lt;= 9</code></li> <li><code>It is guaranteed that the list represents a number that does not have leading zeros.</code></li> </ul>","tags":["Linked List","Math","Recursion"]},{"location":"solutions/2/#solutions","title":"Solutions","text":"","tags":["Linked List","Math","Recursion"]},{"location":"solutions/2/#approach-1-simulation","title":"Approach 1: Simulation","text":"<p>\u2705 Time complexity: O(max((M,N)))</p> <p>\u2705 Space complexity: O(1)</p> <p>Notes:</p> <p>We traverse two linked lists and at the same time, and use the variable <code>carry</code> to indicate whether there is a carry.</p> <p>Each time we traverse, we take out the current bit of the corresponding linked list, calculate the sum with the carry <code>carry</code>, and then update the value of the carry. Then we add the current bit to the answer linked list.</p> <p>If both linked lists are traversed, and the carry is 0, the traversal ends.</p> <p>Finally, we return the head node of the answer linked list.</p> <p>The time complexity is O(max((M,N))), where M and N are the lengths of the two linked lists. We need to traverse the entire position of the two linked lists, and each position only needs O(1) time. Ignoring the space consumption of the answer, the space complexity is O(max((M,N))).</p> PythonJavaC++GoTypeScriptRustJavaScriptC#PHPScalaSwiftRubyKotlinNimCangjie <pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:\n        dummy = ListNode(0)\n        curr = dummy\n        carry = 0\n        while l1 or l2 or carry:\n            if l1:\n                carry+=l1.val\n                l1 = l1.next\n            if l2:\n                carry+=l2.val\n                l2 = l2.next\n            curr.next = ListNode(carry%10)\n            carry = carry//10\n            curr = curr.next\n        return dummy.next\n</code></pre> <pre><code>class Solution {\n    public int[] twoSum(int[] nums, int target) {\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n\n    }\n};\n</code></pre> <pre><code>func twoSum(nums []int, target int) []int {\n}\n</code></pre> <pre><code>function twoSum(nums: number[], target: number): number[] {}\n</code></pre> <pre><code>impl Solution {\n    pub fn two_sum(nums: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;i32&gt; {\n\n    }\n}\n</code></pre> <pre><code>/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number[]}\n*/\nvar twoSum = function (nums, target) {}\n</code></pre> <pre><code>public class Solution {\n    public int[] TwoSum(int[] nums, int target) {\n    }\n}\n</code></pre> <pre><code>class Solution {\n    /**\n    * @param Integer[] $nums\n    * @param Integer $target\n    * @return Integer[]\n    */\n    function twoSum($nums, $target) {\n    }\n}\n</code></pre> <pre><code>object Solution {\n    def twoSum(nums: Array[Int], target: Int): Array[Int] = {\n    }\n}\n</code></pre> <pre><code>class Solution {\n    func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] {\n\n    }\n}\n</code></pre> <pre><code># @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer[]}\ndef two_sum(nums, target)\n\nend\n</code></pre> <pre><code>class Solution {\n    fun twoSum(nums: IntArray, target: Int): IntArray {\n\n    }\n}\n</code></pre> <pre><code>proc twoSum(nums: seq[int], target: int): seq[int] =\n</code></pre> <pre><code>class Solution {\n    func twoSum(nums: Array&lt;Int64&gt;, target: Int64): Array&lt;Int64&gt; {\n\n    }\n}\n</code></pre>","tags":["Linked List","Math","Recursion"]},{"location":"solutions/2226/","title":"2226. Maximum Candies Allocated to K Children","text":"","tags":["Array","Binary Search"]},{"location":"solutions/2226/#2226-maximum-candies-allocated-to-k-children","title":"2226. Maximum Candies Allocated to K Children","text":"","tags":["Array","Binary Search"]},{"location":"solutions/2226/#description","title":"Description","text":"<p>You are given a 0-indexed integer array candies. Each element in the array denotes a pile of candies of size candies[i]. You can divide each pile into any number of sub piles, but you cannot merge two piles together.</p> <p>You are also given an integer k. You should allocate piles of candies to k children such that each child gets the same number of candies. Each child can be allocated candies from only one pile of candies and some piles of candies may go unused.</p> <p>Return the maximum number of candies each child can get.</p> <p>Example 1:</p> <pre><code>Input: candies = [5,8,6], k = 3\nOutput: 5\nExplanation: We can divide candies[1] into 2 piles of size 5 and 3, and candies[2] into 2 piles of size 5 and 1. We now have five piles of candies of sizes 5, 5, 3, 5, and 1. We can allocate the 3 piles of size 5 to 3 children. It can be proven that each child cannot receive more than 5 candies.\n</code></pre> <p>Example 2:</p> <pre><code>Input: candies = [2,5], k = 11\nOutput: 0\nExplanation: There are 11 children but only 7 candies in total, so it is impossible to ensure each child receives at least one candy. Thus, each child gets no candy and the answer is 0.\n</code></pre> <p>Constraints:</p> <ul> <li><code>1 &lt;= candies.length &lt;= 105</code></li> <li><code>1 &lt;= candies[i] &lt;= 107</code></li> <li><code>1 &lt;= k &lt;= 1012</code></li> </ul>","tags":["Array","Binary Search"]},{"location":"solutions/2226/#solutions","title":"Solutions","text":"","tags":["Array","Binary Search"]},{"location":"solutions/2226/#approach-1-applied-binary-search","title":"Approach 1: Applied Binary Search","text":"<p>\u2705 Time complexity: O(nxlog M)</p> <p>\u2705 Space complexity: O(1)</p> <p>Notes</p> <p>We notice that if each child can receive v candies, then for any v' &lt; v, each child can also receive v' candies. Therefore, we can use binary search to find the maximum v such that each child can receive v candies. We define the left boundary of the binary search as l = 0 and the right boundary as r = max(candies), where max(candies) represents the maximum value in the array candies. During the binary search, we take the middle value mid = (l+r+1)//2 = \u230a(l+r+1)/2\u230b each time, and then calculate the total number of candies each child can receive.</p> <p>If the total is greater than or equal to k, it means each child can receive v candies, so we update the left boundary l = mid. Otherwise, we update the right boundary r = mid - 1. Finally, when l = r, we have found the maximum v. The time complexity is O(nxlog M), where n is the length of the array candies, and M is the maximum value in the array candies. The space complexity is O (1).</p>","tags":["Array","Binary Search"]},{"location":"solutions/2226/#way-1","title":"Way 1:","text":"PythonJavaC++GoTypeScriptRustJavaScriptC#PHPScalaSwiftRubyKotlinNimCangjie <pre><code>class Solution:\n    def maximumCandies(self, candies: List[int], k: int) -&gt; int:\n        def f(mid):                     #f - numChildren is a function of candies\n            return sum((c//mid) for c in candies)\n\n        l, r = 1, max(candies)\n        ans = 0\n        while l &lt;=r:\n            mid = (l + r ) // 2\n            if f(mid)&gt;=k:\n                ans = mid\n                l = mid +1\n            else:\n                r = mid -1\n        return ans\n</code></pre> <pre><code>class Solution {\n    public int[] maximumCandies(int[] nums, int target) {\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; maximumCandies(vector&lt;int&gt;&amp; nums, int target) {\n\n    }\n};\n</code></pre> <pre><code>func maximumCandies(nums []int, target int) []int {\n}\n</code></pre> <pre><code>function maximumCandies(nums: number[], target: number): number[] {}\n</code></pre> <pre><code>impl Solution {\n    pub fn two_sum(nums: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;i32&gt; {\n\n    }\n}\n</code></pre> <pre><code>/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number[]}\n*/\nvar maximumCandies = function (nums, target) {}\n</code></pre> <pre><code>public class Solution {\n    public int[] maximumCandies(int[] nums, int target) {\n    }\n}\n</code></pre> <pre><code>class Solution {\n    /**\n    * @param Integer[] $nums\n    * @param Integer $target\n    * @return Integer[]\n    */\n    function maximumCandies($nums, $target) {\n    }\n}\n</code></pre> <pre><code>object Solution {\n    def maximumCandies(nums: Array[Int], target: Int): Array[Int] = {\n    }\n}\n</code></pre> <pre><code>class Solution {\n    func maximumCandies(_ nums: [Int], _ target: Int) -&gt; [Int] {\n\n    }\n}\n</code></pre> <pre><code># @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer[]}\ndef maximumCandies(nums, target)\n\nend\n</code></pre> <pre><code>class Solution {\n    fun maximumCandies(nums: IntArray, target: Int): IntArray {\n\n    }\n}\n</code></pre> <pre><code>proc maximumCandies(nums: seq[int], target: int): seq[int] =\n</code></pre> <pre><code>class Solution {\nfunc maximumCandies(nums: Array&lt;Int64&gt;, target: Int64): Array&lt;Int64&gt; {\n\n        }\n    }\n</code></pre>","tags":["Array","Binary Search"]},{"location":"solutions/2226/#way-2","title":"Way 2:","text":"<p>Tip</p> <ul> <li>Binary Search different than the regular one</li> <li>Problem function is monotonically decresing and we are looking for maximum</li> </ul> Python <pre><code>class Solution:\n    def maximumCandies(self, candies: List[int], k: int) -&gt; int:\n        def f(mid):                    #f - numChildren is a function of candies\n            return sum((c//mid) for c in candies)\n\n        l, r = 0, max(candies)\n        while l&lt;r:\n            mid = (l + r +1) &gt;&gt; 1      #see deviation here from regular binary search\n            if f(mid) &gt;= k:\n                l = mid                #see deviation here from regular binary search\n            else:\n                r = mid - 1            #see deviation here from regular binary search\n        return l\n</code></pre>","tags":["Array","Binary Search"]}]}