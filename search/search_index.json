{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DSA-Online LeetCode Solutions","text":"<p>Welcome to my collection of LeetCode problem solutions!</p> <p>This site contains detailed explanations and implementations of various LeetCode problems.</p>"},{"location":"#problem-categories","title":"Problem Categories","text":"<ul> <li>Array</li> <li>Hash Table</li> <li>Dynamic Programming</li> <li>Tree</li> <li>Graph</li> <li>and more...</li> </ul>"},{"location":"#latest-solutions","title":"Latest Solutions","text":"<ul> <li>1. Two Sum</li> <li>2. Add Two Number</li> </ul>"},{"location":"solutions/1/","title":"1. Two Sum","text":"","tags":["Array","Hash Table"]},{"location":"solutions/1/#1-two-sum","title":"1. Two Sum","text":"","tags":["Array","Hash Table"]},{"location":"solutions/1/#description","title":"Description","text":"<p>Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.</p> <p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p> <p>You can return the answer in any order.</p> <p>Example 1:</p> <pre><code>Input: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n</code></pre> <p>Example 2:</p> <pre><code>Input: nums = [3,2,4], target = 6\nOutput: [1,2]\n</code></pre> <p>Example 3:</p> <pre><code>Input: nums = [3,3], target = 6\nOutput: [0,1]\n</code></pre> <p>Constraints:</p> <ul> <li>2 &lt;= nums.length &lt;= 104</li> <li>-109 &lt;= nums[i] &lt;= 109</li> <li>-109 &lt;= target &lt;= 109</li> <li>Only one valid answer exists.</li> </ul> <p>Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?</p>","tags":["Array","Hash Table"]},{"location":"solutions/1/#solutions","title":"Solutions","text":"","tags":["Array","Hash Table"]},{"location":"solutions/1/#approach-1-hash-table","title":"Approach 1: Hash Table","text":"<p>\u2705 Time complexity: O(n)</p> <p>\u2705 Space complexity: O(n)</p> <p>Notes:</p> <p>We can use the hash table <code>seen</code> to store the array value and the corresponding index.</p> <p>Traverse the array <code>nums</code>, when you find <code>target - nums[i]</code> in the hash table, it means that the target value is found, and the index of <code>target - nums[i]</code> and <code>i</code> are returned.</p> <p>The time complexity is O(n) and the space complexity is O(n). Where n is the length of the array nums.</p> PythonJavaC++GoTypeScriptRustJavaScriptC#PHPScalaSwiftRubyKotlinNimCangjie <pre><code>class Solution:\n    def twoSum(self, nums: List[int], target: int) -&gt; List[int]:\n        seen = {} #map elements with their indexs {ele:idx}\n        for idx,ele in enumerate(nums):\n            num = target - ele\n            if num in seen:\n                return [seen[num],idx]\n            seen[ele] = idx\n</code></pre> <pre><code>class Solution {\n    public int[] twoSum(int[] nums, int target) {\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n\n    }\n};\n</code></pre> <pre><code>func twoSum(nums []int, target int) []int {\n}\n</code></pre> <pre><code>function twoSum(nums: number[], target: number): number[] {}\n</code></pre> <pre><code>impl Solution {\n    pub fn two_sum(nums: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;i32&gt; {\n\n    }\n}\n</code></pre> <pre><code>/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number[]}\n*/\nvar twoSum = function (nums, target) {}\n</code></pre> <pre><code>public class Solution {\n    public int[] TwoSum(int[] nums, int target) {\n    }\n}\n</code></pre> <pre><code>class Solution {\n    /**\n    * @param Integer[] $nums\n    * @param Integer $target\n    * @return Integer[]\n    */\n    function twoSum($nums, $target) {\n    }\n}\n</code></pre> <pre><code>object Solution {\n    def twoSum(nums: Array[Int], target: Int): Array[Int] = {\n    }\n}\n</code></pre> <pre><code>class Solution {\n    func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] {\n\n    }\n}\n</code></pre> <pre><code># @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer[]}\ndef two_sum(nums, target)\n\nend\n</code></pre> <pre><code>class Solution {\n    fun twoSum(nums: IntArray, target: Int): IntArray {\n\n    }\n}\n</code></pre> <pre><code>proc twoSum(nums: seq[int], target: int): seq[int] =\n</code></pre> <pre><code>class Solution {\n    func twoSum(nums: Array&lt;Int64&gt;, target: Int64): Array&lt;Int64&gt; {\n\n    }\n}\n</code></pre>","tags":["Array","Hash Table"]},{"location":"solutions/2/","title":"2. Add Two Number","text":"","tags":["Linked List","Math","Recursion"]},{"location":"solutions/2/#2-add-two-numbers","title":"2. Add Two Numbers","text":"","tags":["Linked List","Math","Recursion"]},{"location":"solutions/2/#description","title":"Description","text":"<p>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.</p> <p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p> <p>Example 1:</p> <p></p> <pre><code>Input: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n</code></pre> <p>Example 2:</p> <pre><code>Input: l1 = [0], l2 = [0]\nOutput: [0]\n</code></pre> <p>Example 3:</p> <pre><code>Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n</code></pre>","tags":["Linked List","Math","Recursion"]},{"location":"solutions/2/#constraints","title":"Constraints:","text":"<ul> <li><code>The number of nodes in each linked list is in the range [1, 100].</code></li> <li><code>0 &lt;= Node.val &lt;= 9</code></li> <li><code>It is guaranteed that the list represents a number that does not have leading zeros.</code></li> </ul>","tags":["Linked List","Math","Recursion"]},{"location":"solutions/2/#solutions","title":"Solutions","text":"","tags":["Linked List","Math","Recursion"]},{"location":"solutions/2/#approach-1-simulation","title":"Approach 1: Simulation","text":"<p>\u2705 Time complexity: O(max((M,N)))</p> <p>\u2705 Space complexity: O(1)</p> <p>Notes:</p> <p>We traverse two linked lists and at the same time, and use the variable <code>carry</code> to indicate whether there is a carry.</p> <p>Each time we traverse, we take out the current bit of the corresponding linked list, calculate the sum with the carry <code>carry</code>, and then update the value of the carry. Then we add the current bit to the answer linked list.</p> <p>If both linked lists are traversed, and the carry is 0, the traversal ends.</p> <p>Finally, we return the head node of the answer linked list.</p> <p>The time complexity is O(max((M,N))), where M and N are the lengths of the two linked lists. We need to traverse the entire position of the two linked lists, and each position only needs O(1) time. Ignoring the space consumption of the answer, the space complexity is O(max((M,N))).</p> PythonJavaC++GoTypeScriptRustJavaScriptC#PHPScalaSwiftRubyKotlinNimCangjie <pre><code># Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -&gt; Optional[ListNode]:\n        dummy = ListNode(0)\n        curr = dummy\n        carry = 0\n        while l1 or l2 or carry:\n            if l1:\n                carry+=l1.val\n                l1 = l1.next\n            if l2:\n                carry+=l2.val\n                l2 = l2.next\n            curr.next = ListNode(carry%10)\n            carry = carry//10\n            curr = curr.next\n        return dummy.next\n</code></pre> <pre><code>class Solution {\n    public int[] twoSum(int[] nums, int target) {\n    }\n}\n</code></pre> <pre><code>class Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n\n    }\n};\n</code></pre> <pre><code>func twoSum(nums []int, target int) []int {\n}\n</code></pre> <pre><code>function twoSum(nums: number[], target: number): number[] {}\n</code></pre> <pre><code>impl Solution {\n    pub fn two_sum(nums: Vec&lt;i32&gt;, target: i32) -&gt; Vec&lt;i32&gt; {\n\n    }\n}\n</code></pre> <pre><code>/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number[]}\n*/\nvar twoSum = function (nums, target) {}\n</code></pre> <pre><code>public class Solution {\n    public int[] TwoSum(int[] nums, int target) {\n    }\n}\n</code></pre> <pre><code>class Solution {\n    /**\n    * @param Integer[] $nums\n    * @param Integer $target\n    * @return Integer[]\n    */\n    function twoSum($nums, $target) {\n    }\n}\n</code></pre> <pre><code>object Solution {\n    def twoSum(nums: Array[Int], target: Int): Array[Int] = {\n    }\n}\n</code></pre> <pre><code>class Solution {\n    func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] {\n\n    }\n}\n</code></pre> <pre><code># @param {Integer[]} nums\n# @param {Integer} target\n# @return {Integer[]}\ndef two_sum(nums, target)\n\nend\n</code></pre> <pre><code>class Solution {\n    fun twoSum(nums: IntArray, target: Int): IntArray {\n\n    }\n}\n</code></pre> <pre><code>proc twoSum(nums: seq[int], target: int): seq[int] =\n</code></pre> <pre><code>class Solution {\n    func twoSum(nums: Array&lt;Int64&gt;, target: Int64): Array&lt;Int64&gt; {\n\n    }\n}\n</code></pre>","tags":["Linked List","Math","Recursion"]}]}